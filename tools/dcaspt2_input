#!/usr/bin/env python3

from subprocess import PIPE, Popen
import argparse
from pathlib import Path
import datetime
import glob
import os
import shutil
import signal
import sys
import tempfile
from datetime import datetime
from typing import Tuple


class ExitWithHelpArgumentParser(argparse.ArgumentParser):
    """A custom ArgumentParser class that exits with help message when the unrecognized arguments are specified"""

    def error(self, message):
        print(f"\nError: Invalid arguments : {message}\nPlease check the following help message and try again.\n")
        self.print_help(sys.stderr)
        self.exit(2, f"\nError: Invalid argument : {message}\n")


def parse_args() -> "argparse.Namespace":
    """Parse user input arguments

    Returns:
        argparse.Namespace: User input arguments (argv)
    """
    desc = "\
======================================== dcaspt2 ========================================\n\
dirac-caspt2 wrapper script.\n\
You can can calculate the CASPT2 energy of a molecule using this script.\n\
You need to prepare the DIRAC (http://diracprogram.org) 1-2 integrals file in advance.\n\
==========================================================================================\n"

    parser = ExitWithHelpArgumentParser(description=desc, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("-i", "--inp", type=str, dest="input", help="Input file [default: active.inp]")
    parser.add_argument("-o", "--out", type=str, dest="output", help="Specify the name of output file [default: dirac_caspt2.out]")
    parser.add_argument("--int", dest="integrals", help="Specify the directory where 1-2 integrals files are stored.\n[default: current directory]", metavar="1-2_INTEGRALS_DIR")
    parser.add_argument("--ivo", action="store_true", help="Run ivo calculation only [default: False]")
    parser.add_argument("--mpi", dest="mpi", type=int, default=1, help="Specify the number of MPI process. [default: 1]", metavar="NUM_MPI_PROCESS")
    parser.add_argument(
        "--omp",
        dest="threads",
        type=int,
        help="Specify the number of OpenMP threads per (MPI) process.\nThis option overrides the OMP_NUM_THREADS environment variable.\n[default: $OMP_NUM_THREADS]",
        metavar="NUM_OMP_THREADS",
    )
    parser.add_argument(
        "--get",
        dest="get",
        type=str,
        help='Specify the name of the files to be copied from the scratch directory.\n\
Wildcard is available.\n\
(e.g.) --get "MDCINTNEW*" => Copy MDCINTNEW, MDCINTNEW1, MDCINTNEW2, ...\n\
[default: None]\n\
(Note: The file name must be enclosed in double quotes or single quotes to prevent shell expansion.)\n',
        metavar='"FILES"',
    )
    parser.add_argument(
        "--scratch",
        dest="scratchdir",
        type=str,
        help="Set the scratch directory. Add the subdirectory to the specified directory.\n(e.g.) --scratch /home/username/scratch \n=> Create /home/username/scratch/active_2020-01-01_12-34-56 directory.\n[default: ~/dcaspt2_scratch]",
    )
    parser.add_argument("--scratchfull", dest="scratchfull", type=str, help="Set the scratch directory. Use the specified directory as the scratch directory.\n[default: None]")
    parser.add_argument(
        "--only-casci", dest="onlycasci", action="store_true", help="Run CASCI calculation only. [default: False]\nThis option cannot be used at the same time with --skip-casci option."
    )
    parser.add_argument(
        "--skip-casci", dest="skipcasci", action="store_true", help="Skip the CASCI calculation. [default: False]\nThis option cannot be used at the same time with --only-casci option."
    )
    parser.add_argument(
        "--no-scratch",
        dest="noscratch",
        help="Force not to use the scratch directory.\n\
Calculate at the current directory.\n\
[default: False]\n\
(Note: Temporary files will remain in the current directory.\n\
You can prevent file copying if there are 1 or 2 electronic integral files and input files\n\
in the current directory in advance.\n\
Therefore, this option is recommended only you concern about disk space.)",
        action="store_true",
    )
    parser.add_argument("-s", "--save", "--keep_scratch", dest="save", action="store_true", help="Save the scratch directory after calculation. [default: False]")

    return parser.parse_args()


def create_scratch_dir(args: "argparse.Namespace", input_file_path: Path, user_submitted_dir: Path) -> Path:
    """Create a temporary directory and return the path to the directory

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        input_file_path (Path): Path to the input file
        user_submitted_dir (Path): Path to the directory where this script is used

    Returns:
        scratch_dir (Path): Path to the temporary directory
    """

    # ================
    #  Sub functions
    # ================

    def permission_denied_error_message(scratch_dir: Path) -> None:
        """Print error message when permission denied

        Args:
            scratch_dir (Path): Path to the temporary directory
        """
        print(f"Permission denied: You do not have permission to create the directory '{scratch_dir}'.")
        print("Please specify the directory that you have permission to create.")
        print("Error: Failed to create the temporary directory.\nExiting...")

    # ================
    #  Main process
    # ================

    # If --scratchfull is specified, Use the specified directory as the scratch directory
    if args.scratchfull is not None:
        scratch_dir = Path(args.scratchfull).expanduser().resolve()
        try:
            os.makedirs(scratch_dir, exist_ok=True)
        except PermissionError:
            permission_denied_error_message(scratch_dir)
            sys.exit(PermissionError.errno)
        return scratch_dir

    # --scratch option, Create the root scratch directory path
    root_scr_dir = Path("~/dcaspt2_scratch").expanduser().resolve()
    if args.scratchdir:
        expand_root = Path(expand_root).expanduser()
        if expand_root.is_absolute():
            root_scr_dir = expand_root.resolve()
        else:  # relative path
            root_scr_dir = Path(user_submitted_dir, expand_root).resolve()

    try:
        os.makedirs(root_scr_dir, exist_ok=True)
    except PermissionError:
        permission_denied_error_message(root_scr_dir)
        sys.exit(PermissionError.errno)

    # Preprocess to create scratch dir name
    input_file_name =  input_file_path.stem  # Remove the extension (e.g. /path/to/active.inp => active)
    if input_file_name == "":
        input_file_name = "input"
    time_string: str = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

    # Set the temporary directory's prefix using the input file name and the current time (e.g. input_2020-01-01_12-34-56_)
    prefix: str = f"{input_file_name}_{time_string}_"

    # Create a temporary directory (e.g. /home/username/dcaspt2_scratch/input_2020-01-01_12-34-56_XXXXXX)
    scratch_dir = tempfile.mkdtemp(dir=root_scr_dir, prefix=prefix)
    os.chmod(scratch_dir, 0o755)  # tempfile.mkdtemp creates a directory with 0o700 permission. So we change the permission to 0o755.
    scratch_dir = Path(scratch_dir).resolve()
    return scratch_dir


def copy_essential_files_to_scratch_dir(args: "argparse.Namespace", input_file_path: Path, integrals_dir: Path, scratch_dir: Path) -> None:
    """Copy input file and integral files to scratch directory
    Args:
        input_file_path (Path): Path to the input file
        integrals_dir (Path): Directory that 1-2 integrals files are stored
        scratch_dir (Path): Path to the temporary directory

    Returns:
        None
    """

    input_file_dir = input_file_path.parent  # (e.g. /home/username/active.inp => /home/username)
    if input_file_dir != scratch_dir:
        shutil.copy(input_file_path, scratch_dir)
    scratch_input_file_path = scratch_dir / input_file_path.name
    scratch_input_file_path.rename(scratch_dir / "active.inp")  # Rename the input file to "active.inp"
    if integrals_dir != scratch_dir:  # If the 1-2 integrals file is not in the temporary directory, copy the 1-2 integrals file to the temporary directory
        # Create a symbolic link to the 1-2 integrals file
        scratch_mrconee_path = scratch_dir / "MRCONEE"
        scratch_mrconee_path.symlink_to(integrals_dir / "MRCONEE")
        if args.ivo:
            scratch_dfpcmo_path = scratch_dir / "DFPCMO"
            scratch_dfpcmo_path.symlink_to(integrals_dir / "DFPCMO")
        mdcints = integrals_dir / "MDCIN*"
        for file in glob.glob(str(mdcints)):
            file_name = Path(file).name
            scratch_mdcint_path = Path(scratch_dir, file_name)
            scratch_mdcint_path.symlink_to(integrals_dir / file_name)
        print("log : Copied 1-2 integral files to the scratch directory")
    return None


def set_integrals_dir(args: "argparse.Namespace", user_submitted_dir: Path) -> Path:
    """Set the directory to the 1-2 integrals file

    default: user_submitted_dir
    otherwise: args.integrals

    Args:
        args ("argparse.Namespace"):User input arguments (argv)
        user_submitted_dir (Path): Path to the directory where this script is used

    Returns:
        integrals_dir (Path): Directory that 1-2 integrals files are stored
    """
    if args.integrals is None:
        integrals_dir = user_submitted_dir.resolve()
    else:
        expand_integrals = Path(args.integrals).expanduser()
        if expand_integrals.is_absolute():  # absolute path
            integrals_dir = expand_integrals.resolve()
        else:  # relative path
            integrals_dir = Path(user_submitted_dir, expand_integrals).resolve()
    return integrals_dir


def check_integral_files(integrals_dir: Path) -> None:
    """Check if the 1-2 integral files exist"""
    files = ["MDCINT", "MRCONEE"]
    for file in files:
        integral_path = (integrals_dir / file).resolve()
        if not integral_path.exists():
            raise Exception(
                f"\n{integral_path} file is not found under {integrals_dir}.\nPlease specify the directory where 1-2 integrals files are stored with the -int or --integrals option.\n(e.g.) If you saved a MDCINT file at /home/username/H2O/MDCINT, use the following command: dcaspt2 -i input_file_path --int /home/username/H2O/.\n For more information, please use the --help option ( dcaspt2 --help )."
            )
    return


def create_command(args: "argparse.Namespace", binary_dir: Path) -> str:
    """Create a command to run dcaspt2

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        binary_dir (Path): Path to the directory where the compiled binaries are stored

    Returns:
        str: Created command
    """
    # --omp option
    if args.threads is None:
        pass  # This script don't set OMP_NUM_THREADS
    elif args.threads <= 1:
        os.environ["OMP_NUM_THREADS"] = "1"
    else:
        os.environ["OMP_NUM_THREADS"] = str(args.threads)

    # --mpi option
    mpi = ""
    if args.mpi > 1:
        mpi = f"mpirun -np {args.mpi}"

    # Create a command
    ivo_path = binary_dir / "r4divocoexe"
    casci_path = binary_dir / "r4dcascicoexe"
    caspt2_path = binary_dir / "r4dcaspt2ocoexe"
    if args.skipcasci and args.onlycasci:
        # --skip-casci and --only-casci cannot be used at the same time
        sys.exit("Error: --skip-casci and --only-casci cannot be used at the same time")
    if args.ivo:
        command = f"{mpi} {ivo_path}"
    elif args.onlycasci:
        command = f"{mpi} {casci_path}"
    elif args.skipcasci:
        command = f"{mpi} {caspt2_path}"
    else:
        command = f"{mpi} {casci_path} && {mpi} {caspt2_path}"
    print(f"Created command : {command}")
    return command


def run_command(args: "argparse.Namespace", command: str, scratch_dir: Path, user_submitted_dir: Path, output_file_path: Path) -> None:
    """Run the dcaspt2 command

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        command (str): Command to run dcaspt2
        scratch_dir (Path): Path to the scratch directory
        user_submitted_dir (Path): Path to the directory where this script is used
        output_file_path (Path): Path to the output file
    """

    def delete_scratch_dir():
        # Delete the scratch directory if the user didn't specify the -s or --save option and --noscratch option
        if not args.noscratch and not args.save and scratch_dir.exists():
            shutil.rmtree(scratch_dir)

    def get_elapsed_time(start_time: datetime, end_time: datetime) -> Tuple[int, int, int, int, float]:
        """Get the elapsed time

        Args:
            start_time (datetime): Start time
            end_time (datetime): End time

        Returns:
            Tuple[int, int, int, int, float]: Elapsed time (days, hours, minutes, seconds, seconds)
        """
        diff_time = end_time - start_time
        time_hours = diff_time.seconds // 3600
        time_minutes = (diff_time.seconds % 3600) // 60
        time_seconds = diff_time.seconds % 60
        return diff_time.days, time_hours, time_minutes, time_seconds, diff_time.microseconds

    os.chdir(scratch_dir)

    with open(output_file_path, "w") as f:
        start_time = datetime.now()
        start_time_float = start_time.timestamp()
        start_time_string = start_time.strftime("%Y-%m-%d %H:%M:%S")

        try:
            p = Popen(command, shell=True, stdout=f, stderr=PIPE)
            p.wait()
        except KeyboardInterrupt:
            delete_scratch_dir()
            print("Calculation was interrupted by the user.(ctrl+c, SIGINT)")
            sys.exit(signal.SIGINT)

        end_message = ""
        if p.stderr is not None:
            end_message += "\n================= Standard error =================\n"
            end_message += p.stderr.read().decode("utf-8")
        user_command = " ".join(sys.argv)
        end_time = datetime.now()
        end_time_float = end_time.timestamp()
        end_time_string = end_time.strftime("%Y-%m-%d %H:%M:%S")
        days, hours, mins, secs, millisecs = get_elapsed_time(start_time, end_time)
        end_message += "\n================= Calculation finished ================\n"
        end_message += f"User Command : {user_command}\n"
        end_message += f"Auto-created Command : {command}\n"
        end_message += f"Scratch directory : {scratch_dir}\n"
        end_message += f"Output file : {output_file_path}\n"
        end_message += f"Calculation started at : {start_time_string}\nCalculation finished at : {end_time_string}\n"
        end_message += f"Elapsed time (sec) : {end_time_float - start_time_float:.4f} sec\n"
        end_message += f"Elapsed time : {days} day {hours} hour {mins} min {secs} sec {millisecs} millisecond\n"

        if p.returncode == 0:
            end_message += "NORMAL END OF dirac-caspt2 CALCULATION\n"
        else:
            end_message += f"ERROR: dirac-caspt2 calculation failed with return code {p.returncode}\n"

        # Write the end message to the output file and stdout
        print(end_message)
        f.write(end_message)

        # Copy the specified files from the scratch directory to the user submitted directory
        if args.get is not None:  # and args.noscratch is False:
            if user_submitted_dir == scratch_dir:
                print("The scratch directory is the user submitted directory. No need to copy files.")
            else:
                print(args.get)
                get_files = str(args.get).split()  # Split the string by space
                for file_glob in get_files:  # glob is allowed (e.g.) MDCINTNEW* => MDCINTNEW, MDCINTNEW1, MDCINTNEW2, ...)
                    for file in glob.glob(file_glob):
                        scratch_dir_file = scratch_dir / file
                        print(f"Copying {scratch_dir_file} to {user_submitted_dir}")
                        if scratch_dir_file.exists():
                            try:
                                shutil.copy(scratch_dir_file, user_submitted_dir)
                            except shutil.SameFileError:
                                print(f"File {scratch_dir_file} already exists in {user_submitted_dir}")
                            except PermissionError:
                                print(f"Permission denied: {scratch_dir_file}")
                        else:
                            print(f"File {scratch_dir_file} is not found")

        # Delete the temporary directory if the user didn't specify the -s or --save option and --no-scratch option
        if not args.noscratch and not args.save and os.path.exists(scratch_dir):
            shutil.rmtree(scratch_dir)

        # When the calculation failed, exit with the return code of the calculation
        if p.returncode != 0:
            sys.exit(p.returncode)

        return None


def set_input_file_path(args: "argparse.Namespace", user_submitted_dir: Path) -> Path:
    """Set the path to the input file

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        user_submitted_dir (Path): Path to the directory where this script is used

    Returns:
        Path: Path to the input file
    """
    if args.input is None:
        input_file_path = (user_submitted_dir / "active.inp").resolve()
    else:
        expand_input = Path(args.input).expanduser()
        if expand_input.is_absolute():  # absolute path
            input_file_path = expand_input.resolve()
        else:  # relative path
            input_file_path = (user_submitted_dir / expand_input).resolve()

    # Check if the input file exists
    if not input_file_path.exists():
        print(f"Input file {input_file_path} does not exist")
        print("Please specify the input file path with -i or --input option")
        sys.exit(FileNotFoundError.errno)

    return input_file_path


def set_ouput_file_path(args: "argparse.Namespace", user_submitted_dir: Path) -> Path:
    """Set the path to the output file

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        user_submitted_dir (Path): Path to the directory where this script is used

    Returns:
        Path: Path to the output file
    """
    if args.output is None:
        filename = "dirac_ivo.out" if args.ivo else "dirac_caspt2.out"
        output_file_path = (user_submitted_dir / filename).resolve()
    else:
        expand_output = Path(args.output).expanduser()
        if expand_output.is_absolute():  # absolute path
            output_file_path = expand_output.resolve()
        else:  # relative path
            output_file_path = (user_submitted_dir / expand_output).resolve()

    return output_file_path


def main() -> None:
    user_submitted_dir: Path = Path.cwd().resolve()
    script_path = Path(__file__).resolve()
    binary_dir = script_path.parent
    print("Script path : ", script_path)
    print("Command submitted directory : ", user_submitted_dir)
    args: "argparse.Namespace" = parse_args()

    input_file_path = set_input_file_path(args, user_submitted_dir)
    output_file_path = set_ouput_file_path(args, user_submitted_dir)

    # 1-2 integrals directory
    integrals_dir = set_integrals_dir(args, user_submitted_dir)
    check_integral_files(integrals_dir)

    # Set and create scratch directory
    if args.noscratch:
        scratch_dir = user_submitted_dir
        print(
            f"--no-scratch option : --no-scratch option is specified. The scratch directory is the submitted directory.\n--no-scratch option : Temporary files will remain in the {user_submitted_dir} directory."
        )
    else:
        scratch_dir = create_scratch_dir(args, input_file_path, user_submitted_dir)
        print(f"Scratch directory : {scratch_dir}")
    copy_essential_files_to_scratch_dir(args, input_file_path, integrals_dir, scratch_dir)

    # Create command to execute and run it
    command = create_command(args, binary_dir)
    run_command(args, command, scratch_dir, user_submitted_dir, output_file_path)

    return None


if __name__ == "__main__":
    main()
