#!/usr/bin/env python3

from subprocess import Popen
import argparse
import datetime
import glob
import os
import shutil
import signal
import sys
import tempfile
import time


class ExitWithHelpArgumentParser(argparse.ArgumentParser):
    """A custom ArgumentParser class that exits with help message when the unrecognized arguments are specified"""

    def error(self, message):
        print(f"\nError: Invalid arguments : {message}\nPlease check the following help message and try again.\n")
        self.print_help(sys.stderr)
        self.exit(2, f"\nError: Invalid argument : {message}\n")


def parse_args() -> "argparse.Namespace":
    """Parse user input arguments

    Returns:
        argparse.Namespace: User input arguments (argv)
    """
    desc = "\
======================================== dcaspt2 ========================================\n\
dirac-caspt2 wrapper script.\n\
You can can calculate the CASPT2 energy of a molecule using this script.\n\
You need to prepare the DIRAC (http://diracprogram.org) 1-2 integrals file in advance.\n\
==========================================================================================\n"

    parser = ExitWithHelpArgumentParser(description=desc, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("-i", "--inp", type=str, dest="input", help="Input file [default: active.inp]")
    parser.add_argument("-o", "--out", type=str, dest="output", help="Specify the name of output file [default: dirac_caspt2.out]")
    parser.add_argument("--int", dest="integrals", help="Specify the directory where 1-2 integrals files are stored.\n[default: current directory]", metavar="1-2_INTEGRALS_DIR")
    parser.add_argument("--ivo", action="store_true", help="Run ivo calculation only [default: False]")
    parser.add_argument("--mpi", dest="mpi", type=int, default=1, help="Specify the number of MPI process. [default: 1]", metavar="NUM_MPI_PROCESS")
    parser.add_argument(
        "--omp",
        dest="threads",
        type=int,
        help="Specify the number of OpenMP threads per (MPI) process.\nThis option overrides the OMP_NUM_THREADS environment variable.\n[default: $OMP_NUM_THREADS]",
        metavar="NUM_OMP_THREADS",
    )
    parser.add_argument(
        "--get",
        dest="get",
        type=str,
        help='Specify the name of the files to be copied from the scratch directory.\n\
Wildcard is available.\n\
(e.g.) --get "MDCINTNEW*" => Copy MDCINTNEW, MDCINTNEW1, MDCINTNEW2, ...\n\
[default: None]\n\
(Note: The file name must be enclosed in double quotes or single quotes to prevent shell expansion.)\n',
        metavar='"FILES"',
    )
    parser.add_argument(
        "--scratch",
        dest="scratchdir",
        type=str,
        help="Set the scratch directory. Add the subdirectory to the specified directory.\n(e.g.) --scratch /home/username/scratch \n=> Create /home/username/scratch/active_2020-01-01_12-34-56 directory.\n[default: ~/dcaspt2_scratch]",
    )
    parser.add_argument("--scratchfull", dest="scratchfull", type=str, help="Set the scratch directory. Use the specified directory as the scratch directory.\n[default: None]")
    parser.add_argument(
        "--only-casci", dest="onlycasci", action="store_true", help="Run CASCI calculation only. [default: False]\nThis option cannot be used at the same time with --skip-casci option."
    )
    parser.add_argument(
        "--skip-casci", dest="skipcasci", action="store_true", help="Skip the CASCI calculation. [default: False]\nThis option cannot be used at the same time with --only-casci option."
    )
    parser.add_argument(
        "--no-scratch",
        dest="noscratch",
        help="Force not to use the scratch directory.\n\
Calculate at the current directory.\n\
[default: False]\n\
(Note: Temporary files will remain in the current directory.\n\
You can prevent file copying if there are 1 or 2 electronic integral files and input files\n\
in the current directory in advance.\n\
Therefore, this option is recommended only you concern about disk space.)",
        action="store_true",
    )
    parser.add_argument("-s", "--save", "--keep_scratch", dest="save", action="store_true", help="Save the scratch directory after calculation. [default: False]")

    return parser.parse_args()


def create_scratch_dir(args: "argparse.Namespace", input_file_path: str, user_submitted_dir: str) -> str:
    """Create a temporary directory and return the path to the directory

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        input_file_path (str): Path to the input file
        user_submitted_dir (str): Path to the directory where this script is used

    Returns:
        scratch_dir (str): Path to the temporary directory
    """

    # ================
    #  Sub functions
    # ================

    def permission_denied_error_message(scratch_dir: str) -> None:
        """Print error message when permission denied

        Args:
            scratch_dir (str): Path to the temporary directory
        """
        print(f"Permission denied: You do not have permission to create the directory '{scratch_dir}'.")
        print("Please specify the directory that you have permission to create.")
        print("Error: Failed to create the temporary directory.\nExiting...")

    # ================
    #  Main process
    # ================

    # If --scratchfull is specified, Use the specified directory as the scratch directory
    if args.scratchfull is not None:
        scratch_dir: str = os.path.abspath(os.path.expanduser(args.scratchfull))
        try:
            os.makedirs(scratch_dir, exist_ok=True)
        except PermissionError:
            permission_denied_error_message(scratch_dir)
            sys.exit(PermissionError.errno)
        return scratch_dir

    # --scratch option, Create the root scratch directory path
    root_scr_dir: str = os.path.expanduser("~/dcaspt2_scratch")
    if args.scratchdir:
        expand_root = os.path.expanduser(args.scratchdir)
        if os.path.isabs(expand_root):  # absolute path
            root_scr_dir = os.path.abspath(expand_root)
        else:  # relative path
            root_scr_dir = os.path.abspath(os.path.join(user_submitted_dir, expand_root))

    try:
        os.makedirs(root_scr_dir, exist_ok=True)
    except PermissionError:
        permission_denied_error_message(root_scr_dir)
        sys.exit(PermissionError.errno)

    # Preprocess to create scratch dir name
    input_file_name: str = os.path.splitext(os.path.basename(input_file_path))[0]  # Remove the extension (e.g. active.inp => active)
    if input_file_name == "":
        input_file_name = "input"
    time_string: str = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

    # Set the temporary directory's prefix using the input file name and the current time (e.g. input_2020-01-01_12-34-56_)
    prefix: str = f"{input_file_name}_{time_string}_"

    # Create a temporary directory (e.g. /home/username/dcaspt2_scratch/input_2020-01-01_12-34-56_XXXXXX)
    scratch_dir = tempfile.mkdtemp(dir=root_scr_dir, prefix=prefix)
    os.chmod(scratch_dir, 0o755)  # tempfile.mkdtemp creates a directory with 0o700 permission. So we change the permission to 0o755.
    return scratch_dir


def copy_essential_files_to_scratch_dir(args: "argparse.Namespace", input_file_path: str, integrals_dir: str, scratch_dir: str) -> None:
    """Copy input file and integral files to scratch directory
    Args:
        input_file_path (str): Path to the input file
        integrals_dir (str): Directory that 1-2 integrals files are stored
        scratch_dir (str): Path to the temporary directory

    Returns:
        None
    """

    input_file_dir = os.path.dirname(input_file_path)  # (e.g. /home/username/active.inp => /home/username)
    if input_file_dir != scratch_dir:
        shutil.copy(input_file_path, scratch_dir)
    os.rename(os.path.join(scratch_dir, os.path.basename(input_file_path)), os.path.join(scratch_dir, "active.inp"))  # Rename the input file to "active.inp"
    if integrals_dir != scratch_dir:  # If the 1-2 integrals file is not in the temporary directory, copy the 1-2 integrals file to the temporary directory
        # Create a symbolic link to the 1-2 integrals file
        os.symlink(os.path.join(integrals_dir, "MDCINT"), os.path.join(scratch_dir, "MDCINT"))
        os.symlink(os.path.join(integrals_dir, "MRCONEE"), os.path.join(scratch_dir, "MRCONEE"))
        if args.ivo:
            shutil.copy(os.path.join(integrals_dir, "DFPCMO"), scratch_dir)
        for file in glob.glob(os.path.join(integrals_dir, "MDCINX*")):
            os.symlink(file, os.path.join(scratch_dir, os.path.basename(file)))
        print("log : Copied 1-2 integral files to the scratch directory")
    return None


def set_integrals_dir(args: "argparse.Namespace", user_submitted_dir: str) -> str:
    """Set the directory to the 1-2 integrals file

    default: user_submitted_dir
    otherwise: args.integrals

    Args:
        args ("argparse.Namespace"):User input arguments (argv)
        user_submitted_dir (str): Path to the directory where this script is used

    Returns:
        integrals_dir (str): Directory that 1-2 integrals files are stored
    """
    if args.integrals is None:
        integrals_dir: str = os.path.abspath(user_submitted_dir)
    else:
        expand_integrals = os.path.expanduser(args.integrals)
        if os.path.isabs(expand_integrals):  # absolute path
            integrals_dir = os.path.abspath(expand_integrals)
        else:  # relative path
            integrals_dir = os.path.abspath(os.path.join(user_submitted_dir, expand_integrals))
    return integrals_dir


def check_integral_files(integrals_dir: str) -> None:
    """Check if the 1-2 integral files exist"""
    files = ["MDCINT", "MRCONEE"]
    for file in files:
        if not os.path.exists(os.path.join(integrals_dir, file)):
            raise Exception(
                f"\n{file} file is not found under {integrals_dir}.\nPlease specify the directory where 1-2 integrals files are stored with the -int or --integrals option.\n(e.g.) If you saved a MDCINT file at /home/username/H2O/MDCINT, use the following command: dcaspt2 -i input_file_path --int /home/username/H2O/.\n For more information, please use the --help option ( dcaspt2 --help )."
            )
    return


def create_command(args: "argparse.Namespace", binary_dir: str) -> str:
    """Create a command to run dcaspt2

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        binary_dir (str): Path to the directory where the compiled binaries are stored

    Returns:
        str: Created command
    """
    # --omp option
    if args.threads is None:
        pass  # This script don't set OMP_NUM_THREADS
    elif args.threads <= 1:
        os.environ["OMP_NUM_THREADS"] = "1"
    else:
        os.environ["OMP_NUM_THREADS"] = str(args.threads)

    # --mpi option
    mpi = ""
    if args.mpi > 1:
        mpi = f"mpirun -np {args.mpi}"

    # Create a command
    ivo_path = os.path.join(binary_dir, "r4divocoexe")
    casci_path = os.path.join(binary_dir, "r4dcascicoexe")
    caspt2_path = os.path.join(binary_dir, "r4dcaspt2ocoexe")
    if args.skipcasci and args.onlycasci:
        # --skip-casci and --only-casci cannot be used at the same time
        sys.exit("Error: --skip-casci and --only-casci cannot be used at the same time")
    if args.ivo:
        command = f"{mpi} {ivo_path}"
    elif args.onlycasci:
        command = f"{mpi} {casci_path}"
    elif args.skipcasci:
        command = f"{mpi} {caspt2_path}"
    else:
        command = f"{mpi} {casci_path} && {mpi} {caspt2_path}"
    print(f"Created command : {command}")
    return command


def run_command(args: "argparse.Namespace", command: str, scratch_dir: str, user_submitted_dir: str, output_file_path: str) -> None:
    """Run the dcaspt2 command

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        command (str): Command to run dcaspt2
        scratch_dir (str): Path to the scratch directory
        user_submitted_dir (str): Path to the directory where this script is used
        output_file_path (str): Path to the output file
    """

    def delete_scratch_dir():
        # Delete the scratch directory if the user didn't specify the -s or --save option and --noscratch option
        if not args.noscratch and not args.save and os.path.exists(scratch_dir):
            shutil.rmtree(scratch_dir)

    os.chdir(scratch_dir)

    with open(output_file_path, "w") as f:
        start_time = time.time()
        start_time_string = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        try:
            p = Popen(command, shell=True, stdout=f, stderr=f)
            p.wait()
        except KeyboardInterrupt:
            delete_scratch_dir()
            print("Calculation was interrupted by the user.(ctrl+c, SIGINT)")
            sys.exit(signal.SIGINT)

        end_time = time.time()
        end_time_string = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        user_command = " ".join(sys.argv)

        end_message = "\n================= Calculation finished ================\n"
        end_message += f"User Command : {user_command}\n"
        end_message += f"Auto-created Command : {command}\n"
        end_message += f"Scratch directory : {scratch_dir}\n"
        end_message += f"Output file : {output_file_path}\n"
        end_message += f"Calculation started at : {start_time_string}\nCalculation finished at : {end_time_string}\n"
        end_message += f"Elapsed time: {end_time - start_time:.4f} sec\n\n"

        if p.returncode == 0:
            end_message += "NORMAL END OF dirac-caspt2 CALCULATION\n"
        else:
            end_message += f"ERROR: dirac-caspt2 calculation failed with return code {p.returncode}\n"

        # Write the end message to the output file and stdout
        print(end_message)
        f.write(end_message)

        # Copy the specified files from the scratch directory to the user submitted directory
        if args.get is not None:  # and args.noscratch is False:
            print(args.get)
            get_files = str(args.get).split()  # Split the string by space
            for file_glob in get_files:  # glob is allowed (e.g.) MDCINTNEW* => MDCINTNEW, MDCINTNEW1, MDCINTNEW2, ...)
                for file in glob.glob(file_glob):
                    print(f"Copying {file} to {user_submitted_dir}")
                    if os.path.isfile(file):
                        try:
                            shutil.copy(file, user_submitted_dir)
                        except shutil.SameFileError:
                            print(f"File {file} already exists in {user_submitted_dir}")
                        except PermissionError:
                            print(f"Permission denied: {file}")
                    else:
                        print(f"File {file} is not found")

        # Delete the temporary directory if the user didn't specify the -s or --save option and --no-scratch option
        if not args.noscratch and not args.save and os.path.exists(scratch_dir):
            shutil.rmtree(scratch_dir)

        # When the calculation failed, exit with the return code of the calculation
        if p.returncode != 0:
            sys.exit(p.returncode)

        return None


def set_input_file_path(args: "argparse.Namespace", user_submitted_dir: str) -> str:
    """Set the path to the input file

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        user_submitted_dir (str): Path to the directory where this script is used

    Returns:
        str: Path to the input file
    """
    if args.input is None:
        input_file_path: str = os.path.abspath(os.path.join(user_submitted_dir, "active.inp"))
    else:
        expand_input = os.path.expanduser(args.input)
        if os.path.isabs(expand_input):  # absolute path
            input_file_path = os.path.abspath(expand_input)
        else:  # relative path
            input_file_path = os.path.abspath(os.path.join(user_submitted_dir, expand_input))

    # Check if the input file exists
    if not os.path.exists(input_file_path):
        print(f"Input file {input_file_path} does not exist")
        print("Please specify the input file path with -i or --input option")
        sys.exit(FileNotFoundError.errno)

    return input_file_path


def set_ouput_file_path(args: "argparse.Namespace", user_submitted_dir: str) -> str:
    """Set the path to the output file

    Args:
        args ("argparse.Namespace"): User input arguments (argv)
        user_submitted_dir (str): Path to the directory where this script is used

    Returns:
        str: Path to the output file
    """
    if args.output is None:
        filename = "dirac_ivo.out" if args.ivo else "dirac_caspt2.out"
        output_file_path: str = os.path.abspath(os.path.join(user_submitted_dir, filename))
    else:
        expand_output = os.path.expanduser(args.output)
        if os.path.isabs(expand_output):  # absolute path
            output_file_path = os.path.abspath(expand_output)
        else:  # relative path
            output_file_path = os.path.abspath(os.path.join(user_submitted_dir, expand_output))

    return output_file_path


def main() -> None:
    user_submitted_dir: str = os.getcwd()
    script_path: str = os.path.abspath(__file__)
    binary_dir: str = os.path.dirname(script_path)
    print("Script path : ", script_path)
    print("Command submitted directory : ", user_submitted_dir)
    args: "argparse.Namespace" = parse_args()

    input_file_path: str = set_input_file_path(args, user_submitted_dir)
    output_file_path: str = set_ouput_file_path(args, user_submitted_dir)

    # 1-2 integrals directory
    integrals_dir: str = set_integrals_dir(args, user_submitted_dir)
    check_integral_files(integrals_dir)

    # Set and create scratch directory
    if args.noscratch:
        scratch_dir: str = user_submitted_dir
        print(
            f"--no-scratch option : --no-scratch option is specified. The scratch directory is the submitted directory.\n--no-scratch option : Temporary files will remain in the {user_submitted_dir} directory."
        )
    else:
        scratch_dir = create_scratch_dir(args, input_file_path, user_submitted_dir)
        print(f"Scratch directory : {scratch_dir}")
    copy_essential_files_to_scratch_dir(args, input_file_path, integrals_dir, scratch_dir)

    # Create command to execute and run it
    command = create_command(args, binary_dir)
    run_command(args, command, scratch_dir, user_submitted_dir, output_file_path)

    return None


if __name__ == "__main__":
    main()
