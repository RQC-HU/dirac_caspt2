#!/usr/bin/env python

# SPDX-FileCopyrightText: 2022 Kohei Noda kohei-noda@hiroshima-u.ac.jp

import argparse
import logging
import os
import shutil
from subprocess import Popen, PIPE


def define_args():
    parser = argparse.ArgumentParser(description="This script is used as a setup script for this project.")
    parser.add_argument("--build", action="store_true", help="Build the project after the setup. [default: False]")
    parser.add_argument("--build-type", type=str, help="Specify the build type. (release, debug can be specified.) [default: release]")
    parser.add_argument("--fc", type=str, help="The path to the Fortran compiler.(If not specified, the default compiler will be used.)")
    parser.add_argument("--flags", type=str, help="The compiler flags.(If not specified, the default flags will be used.)")
    parser.add_argument("-j", "--parallel", type=int, default=1, help="Specify the number of build processes. This option is used only when the --build option is specified. [default: 1]")
    parser.add_argument("--mpi", action="store_true", help="Enable MPI support. The path to the MPI compiler should be specified in the --fc option.[default compiler: mpiifort]")
    parser.add_argument("--no-mkl", action="store_true", help="Disable MKL support. The path to the BLAS/LAPACK library should be specified in the --flags option.")
    parser.add_argument("--omp", "--openmp", action="store_true", help="Enable OpenMP support.")
    parser.add_argument("--prefix", type=str, metavar="INSTALL_DIR", help="Specify the installation directory. [default: ./bin]")
    return parser.parse_args()


def preprocess(args, exec_path, root_path):
    def check_cmake_is_installed():
        print("Checking if CMake is installed...")
        try:
            process = Popen("cmake --version", shell=True, stdout=PIPE, stderr=PIPE)
            stdout, stderr = process.communicate()
            cmake_version = stdout.decode("utf-8").split("\n")[0].split(" ")[2]  # (e.g.) 3.20.0-rc3
            cmake_major_version = int(cmake_version.split(".")[0])  # (e.g.) 3
            cmake_minor_version = int(cmake_version.split(".")[1])  # (e.g.) 20
            logging.info(f"Your CMake version is {cmake_version}")
            if process.returncode != 0:
                logging.error("CMake is not installed!")
                logging.error(f"Error message : {stderr.decode('utf-8')}")
                exit(1)
            elif cmake_major_version < 3 or (cmake_major_version == 3 and cmake_minor_version < 14):
                logging.error("Your CMake version is too old!")
                logging.error("CMake version 3.14 or later is required.")
                logging.error("Please install CMake 3.14 or later.")
                exit(1)
            logging.info(f"CMake is set up correctly! {stdout.decode('utf-8')}")
        except Exception as e:
            logging.error("CMake is not installed!, Aborting...")
            raise Exception(e)

    def clean_dir():
        logging.info("Cleaning the build directory...")
        remove_dirs = ["build", "bin"]
        for rmdir in remove_dirs:
            if os.path.exists(rmdir):
                shutil.rmtree(rmdir)
                logging.info(f"Removed the directory {os.path.abspath(rmdir)}")

    check_cmake_is_installed()
    clean_dir()

    cmake_flags = ""
    logging.info("Configuring cmake build flags...")

    if args.fc is not None:
        # CMAKE_<LANG>_COMPILER: https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER.html#variable:CMAKE_%3CLANG%3E_COMPILER
        cmake_flags += f" -DCMAKE_Fortran_COMPILER={args.fc}"
    if args.flags is not None:
        # CMAKE_<LANG>_FLAGS: https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html#variable:CMAKE_%3CLANG%3E_FLAGS
        cmake_flags += f" -DCMAKE_Fortran_FLAGS='{args.flags}'"

    if args.no_mkl:
        cmake_flags += " -DMKL=off"

    if args.build_type is None:  # If --build-type option is not specified, set it to release.
        logging.info('Build type is "release"')
        cmake_flags += " -DCMAKE_BUILD_TYPE=release"
    else:
        build_type = args.build_type.lower()
        if build_type == "release" or build_type == "debug":
            logging.info(f'Build type is "{build_type}"')
            cmake_flags += f" -DCMAKE_BUILD_TYPE={build_type}"
        else:
            logging.error('Invalid build type. The build type should be "release" or "debug".')
            exit(1)
    if args.mpi:
        if args.fc is None:
            cmake_flags += " -DCMAKE_Fortran_COMPILER=mpiifort"
        cmake_flags += " -DMPI=ON"
    if args.omp:
        cmake_flags += " -DOPENMP=ON"
    if args.prefix is None:  # User did not specify the installation directory.
        pass  # If --prefix option is not specified, the default installation directory defined in CMakeLists.txt will be used.
    else:  # User specified the installation directory.
        if args.prefix.startswith("/"):  # Absolute path
            prefix = os.path.abspath(args.prefix)
        else:  # Relative path
            prefix = os.path.abspath(os.path.join(exec_path, args.prefix))
        logging.info(f"Installation directory is {prefix}")
        cmake_flags += f" -DCMAKE_INSTALL_PREFIX={prefix}"
    return cmake_flags


def configure_source(cmake_flags):
    logging.info(f"CMake flags are {cmake_flags}")
    if not os.path.exists("build"):
        os.mkdir("build")
    command = "cmake -B build" + cmake_flags
    with open("cmake_build_command.log", "w") as f:
        f.write(command)
    logging.info(f"BUILD COMMAND is {command}")
    logging.info("Build command is saved in cmake_build_command.log")
    process = Popen(command, shell=True)
    process.wait()
    if process.returncode != 0:
        logging.error("Failed to configure the source code!")
        exit(1)
    logging.info("Successfully configured the source code.")


def build(args):
    num_of_process = args.parallel
    process = Popen(f"cmake --build build -j {num_of_process}", shell=True)
    process.wait()
    if process.returncode != 0:
        logging.error("Failed to build the project!")
        exit(1)
    logging.info("Successfully built the project.")


def main():

    logging.info("Start dirac_caspt2 setup script.")
    exec_path = os.getcwd()
    root_path = os.path.dirname(__file__)
    os.chdir(root_path)

    args = define_args()
    cmake_flags = preprocess(args, exec_path, root_path)
    configure_source(cmake_flags)

    if not args.build:
        finish_message = "Finished the setup script.\n\n If you want to build the project, please run the following command: \n\tcmake --build build\n or\n\tmake -C build\n After building the project successfully, you should run tests!\n"
    else:
        build(args)
        finish_message = "Finished the setup script.\n"
    logging.info(finish_message)

    mpi_option_message = " --mpi=[number of MPI processes]" if args.mpi else ""
    omp_option_message = " --omp=[number of OpenMP threads per one process]" if args.omp else ""
    enable_or_disable_mpi = "set" if args.mpi else "do not set"

    logging.info(
        f"[Note]\n\
        About tests\n\
        We recommend you to run tests to check if the build is successful.\n\
        You {enable_or_disable_mpi} --mpi option. Therefore, you should run one of the following tests:\n\
        - Run all tests:\n\
        \tpytest --all{mpi_option_message}{omp_option_message}\n\
        - Run tests excluding the tests long time to run:\n\
        \tpytest{mpi_option_message}{omp_option_message}\n\
        For more logging.information, please read the README.md file."
    )


if __name__ == "__main__":
    logging.basicConfig(format="%(levelname)s : %(message)s", level=logging.INFO)
    main()
