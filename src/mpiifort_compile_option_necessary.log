mpiifort

-m64     generate code for Intel(R) 64 architecture

-mkl[=<arg>]
          link to the Intel(R) Math Kernel Library (Intel(R) MKL) and bring
          in the associated headers
            parallel   - link using the threaded Intel(R) MKL libraries. This
                         is the default when -mkl is specified
            sequential - link using the non-threaded Intel(R) MKL libraries
            cluster    - link using the Intel(R) MKL Cluster libraries plus
                         the sequential Intel(R) MKL libraries

-qopenmp  enable the compiler to generate multi-threaded code based on the
          OpenMP* directives (same as -fopenmp)
          Use -qno-openmp to disable

-mp1      improve floating-point precision

-e90      issue errors for language elements that are not standard in
          Fortran 90 (same as -stand f90 -warn stderrors options)


-integer-size <size>
          specifies the default size of integer and logical variables
            size:  16, 32, 64

-real-size <size>
          specify the size of REAL and COMPLEX declarations, constants,
          functions, and intrinsics
            size: 32, 64, 128

-free     specify source files are in free format. Same as -FR
          -nofree indicates fixed format


 -init=keyword
              [, keyword ]

              Lets you initialize a class of variables
                     to zero or to various numeric exceptional values.

              Arguments:

              keyword           Specifies the initial value for a class of variables. Possible values are:

                                [no]arrays     Determines  whether  the  compiler  initializes  variables  that  are arrays or scalars. Specifying arrays initializes variables that are arrays or scalars.
                                               Specifying noarrays or neither arrays or noarrays initializes only variables that are scalars. You must also specify at least one  other  keyword  when  you
                                               specify keyword noarrays.

                                huge or        minus_huge Determines both of the following:

                                               · whether  the  compiler  initializes  to  the  largest  representable positive or negative real value all uninitialized variables of intrinsic type REAL or
                                                 COMPLEX that are saved, local, automatic, or allocated variables

                                               · whether the compiler initializes to the largest representable positive or negative integer value all uninitialized variables  of  intrinsic  type  INTEGER
                                                 that are saved, local, automatic, or allocated variables

                                infinity or    minus_infinity  Determines  whether  the compiler initializes to positive or negative Infinity all uninitialized variables of intrinsic type REAL or COMPLEX
                                               that are saved, local, automatic, or allocated variables.

                                [no]snan       Determines whether the compiler initializes to signaling NaN all uninitialized variables of intrinsic type REAL or COMPLEX that are saved, local, automatic,
                                               or allocated variables.

                                tiny or        minus_tiny  Determines  whether  the  compiler  initializes  to  the  smallest  representable positive or negative real value all uninitialized variables of
                                               intrinsic type REAL or COMPLEX that are saved, local, automatic, or allocated variables.

                                [no]zero       Determines whether the compiler initializes to zero all uninitialized variables of intrinsic type REAL, COMPLEX, INTEGER, or LOGICAL that are saved,  local,
                                               automatic, or allocated variables.

                                               Option /Qinit:[no]zero replaces option /Qzero[-] (Windows*) , and option -init=[no]zero replaces option -[no]zero (Linux* and macOS*).

              Default:

              OFF               No initializations are performed by default if you do not specify any of these options.

              Description:

              This  option lets you initialize a class of variables to zero or to one or more of the various numeric exceptional values positive or negative huge, positive or negative Infinity, signaling
              NaN, or positive or negative tiny.

              If you only specify the keyword [minus_]huge, [minus_]infinity, snan, [minus_]tiny, or zero, option [Q]init affects only scalar variables. To apply an initialization to arrays as well,  you
              must also specify the keyword arrays.

              If you have specified an ALLOCATE statement and you specify one or more [Q]init keywords, the initializers are applied to the memory that has been allocated by the ALLOCATE statement.

              Keywords are applied to the various numeric types in the following order:

              · For REAL and COMPLEX variables, keywords [minus_]huge, [minus_]infinity, snan, [minus_]tiny, and zero initialize to the specified value.

              · For INTEGER variables, keywords [minus_]huge and zero initialize to the specified value.

              · For LOGICAL variables, keyword zero initializes to .FALSE..

              The following classes of variables are initialized by the [Q]init option:

              · Variables of intrinsic numeric type, that is, of type COMPLEX, INTEGER, LOGICAL, or REAL, of any KIND

              · SAVEd scalar or array variables, not in the main program, that are not initialized in the source code

              · Local scalars and arrays

              · Module variables that are not initialized in the source code

              · Automatic arrays

              · Integers can be set to zero, huge, or minus_huge.

              · In a COMPLEX variable, each of the real and imaginary parts is separately initialized as a REAL.

              The following are general restrictions for this option:

              · The keywords [minus_]infinity, snan, and [minus_]tiny only affect certain variables of REAL or COMPLEX type.

              · You cannot initialize variables in equivalence groups to any of the numeric exceptional values.

              · In  an equivalence group, if no member of that equivalence group has an explicit initialization or a default initialization (in the case of a derived type), a variable in that equivalence
                group can be initialized to zero but not to any of the numeric exceptional values.

              · Derived types, arrays of derived types, and their components will not be initialized.

              · Dummy arguments including adjustable arrays will not be initialized.

              · Variables in COMMON will not be initialized.

              The following spellings all cause the same behavior, that is, they initialize certain numeric arrays and scalars to zero:

              · [Q]init zero [Q]init arrays

              · [Q]init arrays [Q]init zero

              · [Q]init zero, arrays

              · [Q]init arrays, zero

              Combinations of keywords will override each other in a left-to-right fashion as follows:

              · zero and nozero override each other.

              · snan and nosnan override each other.

              · huge and minus_huge override each other.

              · tiny and minus_tiny override each other.

              · infinity, minus_infinity, and snan will all override each other.

              Because a REAL or COMPLEX variable can be initialized to huge or minus_huge, infinity or minus_infinity, tiny or minus_tiny,  snan,  or  zero,  these  initializations  are  applied  in  the
              following order:

              1)

                  snan

              2)

                  infinity or minus_infinity

              3)

                  tiny or minus_tiny

              4)

                  huge or minus_huge

              5)

                  zero

              Because an INTEGER variable can be initialized to huge or minus_huge, or zero, these initializations are applied in the following order:

              1)

                  huge or minus_huge

              2)

                  zero

              For example, if the you specify [Q]init zero, minus_huge, snan when compiling the following program:

              program test real X integer K complex C end

              The  variable  X  will  be  initialized  with  a signaling NaN (snan), variable K will be initialized to the integer value minus_huge, and the real and imaginary parts of variable C will be
              initialized to a signaling NaN (snan) in each.

              If you specify [Q]init snan, the floating-point exception handling flags will be set to trap signaling NaN and halt so that when such a value is trapped at run-time, the Fortran library can
              catch  the  usage,  display  an error message about a possible uninitialized variable, display a traceback, and stop execution. You can use the debugger to determine where in your code this
              uninitialized variable is being referenced when execution stops.

              Setting the option [Q]init snan implicitly sets the option fpe 0. A compile time warning will occur if you specify both option fpe 3 and option [Q]init snan on the  command  line.  In  this
              case, fpe 3 is ignored.

              NOTE:  If  you  build with optimization, the compiler may speculate floating-point operations, assuming the default floating-point environment in which floating-point exceptions are masked.
              When you add [Q]init snan, this speculation may result in exceptions, unrelated to uninitialized variables, that now get trapped. To avoid this, reduce the optimization level to /O1 or  /Od
              (Windows*), or -O1 or -O0 (Linux* and macOS*) when doing uninitialized variable detection.

              If  you  wish  to  maintain optimization, you should add option [Q]fp-speculation safe to disable speculation when there is a possibility that the speculation may result in a floating-point
              exception.

              NOTE: To avoid possible performance issues, you should only use [Q]init for debugging (for example, [Q]init zero) and checking for uninitialized variables (for example, [Q]init snan).

              Use option [Q]save if you wish all variables to be specifically marked as SAVE.

              Alternate Options:

              None
